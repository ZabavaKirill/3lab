<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Технологии графики в современных играх</title>
	<link rel="stylesheet" type="text/css" href="css/main.css">
	<script src="js/jquery-3.0.0.min.js"></script>
</head>
<body>
	<a href="#" title="Вернуться к началу" class="topbutton">Наверх</a>
	<header>
		<div class="container up">
			<h1>
				Обзор реализаций<br>
				3D-графики при разработке<br>
				компьютерных игр
			</h1>
			<div class="clearfix">
			<nav class="menu">
				<ul>
					<li>
						<a href="index.html">Главная<br></a>
					</li>
					<li>
						<a href="evolution.html">Краткая<br> эволюция игр</a>
					</li>
					<li>
						<a href="#">Технологии графики<br> в 	современных играх</a>
						<ul class="dropdown">
							<li><a href="part1.html">Часть 1</a></li>
							<li><a href="part2.html">Часть 2</a></li>
							<li><a href="part3.html">Часть 3</a></li>
						</ul>
					</li>
					<li>
						<a href="about me.html">Об авторе<br> </a>
					</li>
					</ul>
				</nav>
			</div>
		</div>
	</header>
	<section id="main">
		<div class="container">
		<div class="left-menu">
			<a href="#" class="menu-btn">
				<span></span>
			</a>
			<h3>Содержание</h3>
			<ol class="menu-list">
				<li><a href="#intro">Введение</a></li>
				<li><a href="#tressfx">AMD TressFX</a></li>
				<li><a href="#GPU-Particles">Частицы на видеокарте</a></li>
				<li><a href="#voxel_cone_tracing">Воксельная коническая трассировка</a></li>
				<li><a href="#realtime_ambient_occlusion">Realtime Ambient Occlusion</a></li>
			</ol>
		</div>
		<div class="content">
			<h1>Часть 3:<br>новейшие технологии</h1>
			<h2 id="intro">Введение</h2>
			<a href="img/part3.jpg"><img src="img/part3.jpg" alt=""></a>
			<p>Эта часть посвящена самым современным технологиям в компьютерной графике, появившихся с приходом <a definition="Next-Gen - next generation, новое поколение консолей или технологий." href="term.html#Next-Gen">Next-Gen'a</a>. </p>
			<h2 id="tressfx">AMD TressFX</h2>
			<p>Эта технология — просто идеальный пример того, что игровая индустрия сама по себе не придумывает практически никаких технологий. Просто время идёт, мощности <a definition="Железо - электронные и механические части компьютера, входящие в состав системы или сети, исключая программное обеспечение и данные." href="term.html#Computer-parts">железа</a> растут и со временем, пускай и с какими-то упрощениями, становится возможным делать в реалтайме то, что раньше было доступно только в «тяжёлом» <a definition="Рендернинг - термин в компьютерной графике, обозначающий процесс получения изображения по модели с помощью компьютерной программы." href="term.html#Rendering">рендере</a>, то есть, в том, что <a definition="Геймер - человек, играющий в видеоигры, хотя сначала геймерами называли тех, кто играет только в ролевые или военные игры." href="term.html#Gamer">геймеры</a> именуют <a definition="CGI-ролики - движущиеся изображения, сгенерированные при помощи трёхмерной компьютерной графики и использующиеся в изобразительном искусстве, печати, кинематографических спецэффектах." href="term.html#CGI">CGI-роликами</a>.
			Иными словами, практически все технологии, появившиеся в играх — всего лишь упрощённое заимствование того, что уже давным-давно широко используется в кино и изучено вдоль и поперёк.</p>
			<a href="img/tressfx.jpg"><img src="img/tressfx.jpg" alt="TressFX"></a>
			<p>Собственно, что такое TressFX? А очень просто: это всего лишь готовый кусок программного кода от AMD, с помощью которого можно считать волосы персонажа на <a definition="Видеокарта - устройство, преобразующее графический образ, хранящийся как содержимое памяти компьютера, в форму, пригодную для дальнейшего вывода на экран монитора." href="term.html#Videocard">видеокарте</a>. Раньше это делалось на <a definition="Процессор - центральная часть компьютера, выполняющая заданные программой преобразования информации и осуществляющая управление всем вычислительным процессом." href="term.html#Processor">процессоре</a> и требовало непомерное количество ресурсов. Естественно, ни о каком реалтайме и речи быть не могло. Поэтому в играх причёски в любом случае делались такими <a definition="Полигон - минимальная поверхность для визуализации. В качестве полигонов обычно применяют треугольники." href="term.html#Polygon">полигональными</a> «лоскутками», на которых волосы были просто <a definition="Текстура - растровое изображение, накладываемое на поверхность полигональной модели для придания ей цвета, окраски или иллюзии рельефа." href="term.html#Texture">текстурой</a>. А теперь видеокарты улучшились и игровые программисты могут просто взять этот готовый TressFX и воткнуть его в игру: волосы будут считаться в реалтайме на <a definition="GPU - от английского graphics processing unit - графический процессор. Это отдельный процессор расположенный на видеокарте, который выполняет графический рендеринг." href="term.html#CPU">GPU</a>. Считай, ничего делать не надо: покрутил пару параметров, настроил длину — и очередная пара косичек готова. </p>
			<p>Причём, на видеокарте считается не только то, как эти волосы выглядят, но и их физика. То есть, как движется каждый волосок.
			В будущем это даст гораздо большую реалистичность стрижек у персонажей: они будут выглядеть, прямо как настоящие. Но пока что видеокарты попросту не настолько сильные, чтоб держать в кадре множество персонажей с такими причёсками.</p>
			<h2 id="GPU-Particles">GPU Particles - <br>частицы на видеокарте</h2>
			<a href="img/GPU_particles.jpg"><img src="img/GPU_particles.jpg" alt="GPU Particles"></a>
			<p>Всё очень просто: видеокарта лучше справляется с задачами, которые легко распараллелить. Это означает, что видеокарта считает много всего однотипного, а процессор считает что-то одно сложное. В DirectX 11 появилась технология DirectCompute, которая позволяет разработчикам игр самостоятельно считать на GPU практически что угодно. Естественно, благодаря этому те вещи, которые сами по себе хорошо параллелятся первым же делом были перенесены с процессора на видеокарту, что позволило увеличить детализацию этих «вещей» в несколько раз.</p>
			<p>Ярчайший пример — системы частиц. В кадре есть множество маленьких-маленьких объектов вроде песчинок, снежинок, капель воды. Раньше их считали на процессоре, поэтому приходилось исхитряться. Например, рисуя вместо одной частицы текстуру, где их 100. А теперь — их считают на видеокарте, так что можно делать это по-честному вместе со всей физикой. Это позволяет ворочать в кадре буквально миллионами частиц, создавая просто ошеломительные эффекты.</p>
			<h2 id="voxel_cone_tracing">Voxel Cone Tracing -<br> воксельная коническая трассировка.</h2>
			<p>За этим страшным названием скрывается технология для расчёта рассеянного освещения (indirect illumination). Что такое «рассеянное освещение»? Проще будет показать:</p>
			<div class="two_images clearfix">
			<a href="img/voxel_cone_tracing1.jpg"><img src="img/voxel_cone_tracing1.jpg" alt="Voxel Cone Tracing "></a>
			<a href="img/voxel_cone_tracing2.jpg"><img src="img/voxel_cone_tracing2.jpg" alt="Voxel Cone Tracing"></a></div>
			<p>На скриншотах свет попадает только на одну стенку и шторы. Но, отразившись от них (рассеявшись), он освещает всю остальную сцену. При чём, свет от зелёной шторы окрашивает всё в зелёный цвет, а от красной — в красный. В реальной природе свет распространяется так же. Но в играх до последнего времени это было невозможно.</p>
			<p>К сожалению, я пока что не встречал ни одного упоминания о том, чтобы какая-то игра использовала эту технологию. Даже в Battlefield, насколько мне известно, её не стали использовать, хотя поначалу хотели. Но с приходом консолей нового поколения, я очень надеюсь, что скоро она окажется в <a definition="Мейнстрим - преобладающее направление в какой-либо области для определённого отрезка времени." href="term.html#Mainstream">мейнстриме</a>.</p>
			<h2>Tesselation</h2>
			<p>Многие игроки не до конца понимают смысл этой технологии. Большинство считает, что это «такая штука», которая позволяет вместо плоского пола усыпать его камнями. И всё. Вообще, да. Но она может не только это. Сама по себе тесселяция пришла в DX11 из того же самого «тяжёлого рендера», из которого пришли и волосы, вместе с рассеянным светом. К счастью, в отличие от TressFX эта технология гораздо лучше применима.</p>
			<p>Что она делает? А очень просто: интерактивно, прямо во время игры разбивает один большой полигон на кучу маленьких. По сути, благодаря ей можно сделать так, чтоб количество полигонов в кадре всегда было примерно одинаковым. Независимо от того, насколько сильно мы приблизились к поверхности. </p>
			<p>Что это нам даёт? Ну, вообще-то, сама по себе тесселяция ничего не даёт. Но зато, если её комбинировать с другими технологиями можно получить очень красивую картинку. В самом простом случае — да, можно добавить к тесселяции другую технологию (vector displacement), которая по специальной текстуре рельефа «выдавит» точки на тесселированом объекте. Это позволит добавить, собственно, рельеф, сделав прям-таки фотореалистично детализированный уровень.</p>
			<a href="img/tesselation.jpg"><img src="img/tesselation.jpg" alt="Tesselation"></a>
			<p>Но ведь двигать точки на поверхности можно не только по заранее сделанной фиксированной текстуре. Вместо текстуры величину смещения можно получать по какому-нибудь хитрому алгоритму. То есть прямо во время игры, при отрисовке каждого кадра для каждой точки вычисляется, куда её сместить. У текстуры есть <a definition="Разрешение - величина, определяющая количество точек на единицу площади. Термин обычно применяется к изображениям в цифровой форме." href="term.html#Resolution">разрешение</a>. Рано или поздно, когда ты приблизишься — увидишь <a definition="Пиксель - наименьший логический элемент двумерного цифрового изображения в растровой графике.Представляет собой неделимый объект прямоугольной или круглой формы, характеризуемый определённым цветом." href="term.html#Pixel">пиксели</a>. А у алгоритма разрешения нет. То есть, приближать/отдалять можно сколько угодно, не теряя при этом ни детализации, ни производительности. Таким способом (он называется procedural displacement) можно из одной плоскости выдавливать целые ландшафты. И сколь близко бы ты на него ни смотрел — он всегда будет очень детализированным.</p>
			<p>Или такой пример: представьте, что при замерзании персонажа на нём прямо по форме тела вырастают сосульки. Не внезапно появляются из ниоткуда, а именно вырастают. Причём разработчикам для этого достаточно всего лишь 1 раз сделать материал с этим алгоритмом, и потом можно его применять вообще на любой объект. На любой: даже целые уровни можно замораживать, просто накинув на все объекты этот материал. </p>
			<p>В общем, тесселяция напару с процедурным дисплейсментом открывает для разработчиков безграничный арсенал выразительных средств. Кроме того, использование тесселяции позволяет вообще отказаться от технологии LOD (Level of Detail). Это означает, что разработчики за те же деньги смогут сделать больше объектов на уровне и не только сами объекты при близком разглядывании будут более детализированными, но и уровни в целом будут более разнообразными. Но это только если делать игру исключительно с расчётом на DX11 и соответствующее железо.</p>
			<h2 id="realtime_ambient_occlusion">Realtime Ambient Occlusion</h2>
			<p>Эта технология имитирует мягкие тени во «впадинках». Как она работает — объяснить будет очень сложно, да и не нужно. Главное, что для тех точек экрана, которые на уровне находятся в углах или очень близко с которыми находится поверхность другого объекта рисуется затенение. Технология также пришла из «старшей» графики, где она называется просто Ambient Occlusion (АО). В играх она бывает нескольких видов:</p>
			<p><b>SSAO.</b> Расшифровывается как Screen-Space Ambient Occlusion — AO в пространстве экрана. «В пространстве экрана» — это лишь означает способ, которым оно вычисляется. Он сложный и запутанный, так что тут его не объяснишь. Просто именно он позволил считать АО в реалтайме, поэтому попал в название. В наши дни практически любая игра поддерживает SSAO. И если железо позволяет — его лучше включить, потому что этот эффект почти не отжирает ресурсов, но при этом существенно повышает реализм.</p>
			<p><b>HBAO.</b> Horizon Based Ambient Occlusion — AO на основе горизонта. Реализация SSAO от NVIDIA. Если сравнивать с простым SSAO — что-то улучшили, что-то ухудшили. Чтоб корректно сравить разные виды SSAO в статье — надо смотреть «чистый» AO (на белых объектах) и с совершенно одинаковых ракурсов. Но я, к сожалению, таких сравнений не нашёл. Придётся на словах. Избавились от одних артефактов и тем самым сделали алгоритм более физически корректным. Но появились другие артефакты. Ни те, ни другие не описать словами. Но вот в отличие от SSAO, HBAO «дёргается» при движении камеры, что  совсем не хорошо. </p>
			<p>Если выбирать между SSAO и HBAO — первое лучше. Но в скором времени Nvidia разработала слегка усовершенствованную версию — HBAO+. Она избавилась от артефактов «простой» HBAO и практически лишилась «шума». Правда, требует более свежую видеокарту, зато работает немного быстрее. Обычно HBAO медленнее, чем SSAO. Но в некоторых играх с некоторыми видеокартами от NVIDIA — работает быстрее. На видеокартах от AMD — точно медленнее.</p>
			<p><b>HDAO.</b> High Definition Ambient Occlusion — AO высокого разрешения. Реализация от AMD. Картинка натуральнее, чем с HBAO. Но вот со скоростью — те же непонятки. На видеокартах от AMD — быстрее, чем HBAO, но медленне, чем SSAO. На видюхах от NVIDIA — бывает по-разному. В том числе бывает, что HDAO быстрее, чем «родной» HBAO.</p>
			<p>В общем, обычно HDAO/HBAO — медленнее и качественнее, чем SSAO. Качество картинки в любом случае улучшается так: SSAO — HBAO — HBAO+ — HDAO (хотя лично я считаю, что первые два надо поменять местами). Но вот какой вариант быстрее — проще самому попробовать в игре.</p>
		</div>
		</div>
	</section>
	<footer>	
	<div class="container">
		&copy; 2020г <a href="mailto:zabavakirill2000@yandex.ru">Забава Кирилл Николаевич</a> | <a href="map.html">Карта сайта</a> | <a href="term.html">Справочник</a> | <a href="source.html">Список источников</a>
	</div>
</footer>
	<script type="text/javascript">
		$('.menu-btn').on('click', function(e) {
			e.preventDefault();
			$('.left-menu').toggleClass('menu-active');
			$('.content').toggleClass('content-active');
			$('.up').toggleClass('content-active');
		})
		$('.menu-list').on('click', function() {
			$('.left-menu').toggleClass('menu-active');
			$('.content').toggleClass('content-active');
			$('.up').toggleClass('content-active');
		})
	</script>
</body>
</html>